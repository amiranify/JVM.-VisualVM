# JVM. Организация памяти, сборщики мусора, VisualVM
## Задача 1 (обязательная)
Просмотрите код ниже и опишите (текстово или с картинками) каждую строку с точки зрения происходящего в JVM

Не забудьте упомянуть про:

ClassLoader’ы,
области памяти (стэк (и его фреймы), heap)
сборщик мусора
### Код для исследования
```java
public class JvmComprehension {
    public static void main(String[] args) {
        int i = 1;                      // 1
        Object o = new Object();        // 2
        Integer ii = 2;                 // 3
        printAll(o, i, ii);             // 4
        System.out.println("finished"); // 7
    }
    private static void printAll(Object o, int i, Integer ii) {
        Integer uselessVar = 700;                   // 5
        System.out.println(o.toString() + i + ii);  // 6
    }
}
```

Ответ оформите в виде README.md в публичном гитрепо. На проверку скиньте ссылку на этот README.md в вашем репозитории.

# Ответ

1. Объявляется целочисленная переменная i типа int и помещается храниться в *stack*.
2. *ClassLoader* загружает класс **Object**. Создается объект класса **Object** в куче (*heap*), а ссылка для его хранения помещается в *stack*.
3. *ClassLoader* загружает класс **Integer**. Ссылочная переменная **ii** типа **Integer** создаётся в *stack*, а значение переменной будет храниться в куче.
4. В момент вызова метода **printAll()** в *stack* выделяется блок памяти (*frame*) для этого метода.
5. Создается ссылочная переменная **uselessVar** типа **Integer** в *stack*, а значение переменной будет храниться в куче.
6. Объект типа **String** создается в куче (*heap*) и передается методу **println()**. После того, как метод **println()** отработал, работа метода **printAll()** завершается, и его фрейм удаляется из стека.
7.  В heap создается объект *"finished"* типа **String**. String передается методу **println()** для вывода в консоль. После окончания работы метода **println()**, работа метода **main()** завершается, и его *frame* удаляется из *stack*.
